import{_ as t,c as a,o as s,a4 as n}from"./chunks/framework.sQ8wSw9M.js";const p=JSON.parse('{"title":"6. Navegabilitat i concurrència","description":"","frontmatter":{},"headers":[],"relativePath":"6-navegabilitat.md","filePath":"6-navegabilitat.md"}'),l={name:"6-navegabilitat.md"};function r(i,e,o,c,u,d){return s(),a("div",null,e[0]||(e[0]=[n('<h1 id="_6-navegabilitat-i-concurrencia" tabindex="-1">6. Navegabilitat i concurrència <a class="header-anchor" href="#_6-navegabilitat-i-concurrencia" aria-label="Permalink to &quot;6. Navegabilitat i concurrència&quot;">​</a></h1><p>Quan <strong>invoquem a createStatement() sense arguments</strong>, com hem vist anteriorment, en executar sentències SQL obtindrem un <strong>ResultSet per defecte en el qual el cursor només pot moure&#39;s cap avant i les dades són de només lectura</strong>. A vegades això no és suficient i necessitem major funcionalitat.</p><p>Per això el mètode createStatement() està sobrecarregat (existeixen diverses versions d&#39;aquest mètode) la qual cosa ens permet invocar-ho amb arguments en els quals podem especificar el funcionament.</p><ul><li><strong>Statement createStatement(int resultSetType, int resultSetConcurrency)</strong>: Retorna un objecte Statement els objectes del qual ResultSet seran del tipus i concurrència especificats.</li></ul><p>Els valors vàlids són constants definides en ResultSet.</p><p><strong>L&#39;argument resultSetType</strong> indica el tipus de ResultSet:</p><ul><li><strong>ResultSet.TYPE_FORWARD_ONLY</strong>: ResultSet per defecte, forward-only i no-actualitzable. <ul><li>Només permet moviment cap avant amb <code>next()</code>.</li><li>Les seues dades NO s&#39;actualitzen. És a dir, no reflectirà canvis produïts en la base de dades. Conté una instantània del moment en el qual es va realitzar la consulta.</li></ul></li><li><strong>ResultSet.TYPE_SCROLL_INSENSITIVE</strong>: ResultSet desplaçable i no actualitzable. <ul><li>Permet llibertat de moviment del cursor amb altres mètodes com <code>first()</code>, <code>previous()</code>, <code>last()</code>, etc. a més de <code>next()</code>.</li><li>Les seues dades NO s&#39;actualitzen, com en el cas anterior.</li></ul></li><li><strong>ResultSet.TYPE_SCROLL_SENSITIVE</strong>: ResultSet desplaçable i actualitzable. <ul><li>Permet llibertat de moviments del cursor, com en el cas anterior.</li><li>Les seues dades SÍ QUE s&#39;actualitzen. És a dir, <u>mentre el ResultSet estiga obert s&#39;actualitzarà automàticament amb els canvis produïts en la base de dades</u>. Això pot succeir fins i tot mentre s&#39;està recorrent el ResultSet, la qual cosa pot ser convenient o contraproduent segons el cas.</li></ul></li></ul><p>L&#39;argument resultSetConcurrency indica la concurrència del ResultSet:</p><ul><li><strong>ResultSet.CONCUR_READ_ONLY</strong>: Només lectura. És el valor per defecte.</li><li><strong>ResultSet.CONCUR_UPDATABLE</strong>: Permet modificar les dades emmagatzemades en el ResultSet per a després aplicar els canvis sobre la base de dades (més endavant es veurà com).</li></ul><p><strong>El ResultSet per defecte que s&#39;obté amb <code>createStatement()</code> sense arguments és el mateix que amb <code>createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY)</code>.</strong></p>',10)]))}const S=t(l,[["render",r]]);export{p as __pageData,S as default};
